Hi all,

背景介绍
--------------------
   在当前的DNA实现中，存储层在收到共识完的区块并验证后，做区块的存储工作，主要如下：
1. 保存所有的交易；
2. 更新每笔交易的输入列表中引用的之前交易信息；
3. 更新资产信息;
4. 更新交易中相关账户地址中的资产余额信息
5. 更新系统变量如BookKeeper等信息
6. 保存区块头

测试发现上面的步骤涉及了大量的数据库读写和序列化/反序列化操作，比较耗时，而只有上面所有工作做完后，才能进行新一轮的共识，因此是目前DNA的主要性能瓶颈。 在和俊杰讨论之后，我们提出下面的改进思路，欢迎大家提供意见，评估下该方案的可行性。

改进方案
----------------
   为了解决保存区块的时候共识模块一直处于空闲等待的问题。 将保存工作分解为两部分：
   1. 将完整的区块持久化到db，并更新BookKeeper信息
   2. 持久化成功后，启动后台线程再对该区块的每笔交易做处理，更新资产，账户等状态信息

其中在第一步结束后，就可以通知共识模块进行下一轮的区块共识。 由于下一轮的共识需要最新的BookKeeper信息，因此要在第一步做处理。
在第二步结束后，从交易池中清理该区块中的交易。 这样在没有完全处理区块中的交易时，这些交易一直留在交易池中，确保了有冲突的交易无法加入交易池。

宕机重启时的处理
----------------
   在重启初始化chainstore时，首先检查第一步中持久化的block是否全部处理完，如果没有，则依次处理。

交易池的处理
----------------
   由于没有完全处理的区块中的交易留在交易池中，在启动新的共识时，为了防止将这些交易打包到新的区块中进行共识，需要对交易池中的交易作标记。

同步区块的处理
----------------
   目前的实现中同步过来的区块中的交易没有加入交易池中，直接走存储逻辑。 可导致交易池中存在冲突交易的风险，不过冲突的交易在打包进共识上下文中会被其他节点识别，问题不大。不过在改进的方案中，存在其他节点不能识别并对区块进行签名的风险。所以同步过来的区块中的交易需要加入交易池。

chainstore的处理
----------------
  新增DATA_BLOCK， key: DATA_BLOCK+hash, val: serialize(block)
  由于当前的实现中区块的内容被完全打散后存进db，导致GetBlock函数需要做大量的工作将零散的数据重新组装。 新增该字段后，可以加速这个函数。









